/**
 * Classroom Sync Store
 * Uses the Google OAuth token from Supabase Auth session
 * to fetch Google Classroom data and create tasks
 */
import { create } from 'zustand';
import { supabase } from '@/integrations/supabase/client';
import { fetchAllClassroomData, formatClassroomDueDate } from '@/lib/classroomApi';
import type { Task, TaskList } from '@/types/task';
import { useTaskStore } from './taskStore';
import { useUIStore } from './uiStore';
import * as db from '@/lib/database';

interface SyncedCourse {
    id: string;
    name: string;
    listId: string;
}

interface ClassroomState {
    isConnected: boolean;
    isSyncing: boolean;
    lastSyncAt: string | null;
    syncError: string | null;
    syncedCourses: SyncedCourse[];
    importedCourseworkIds: Set<string>;

    loadSyncState: (userId: string) => Promise<void>;
    syncNow: () => Promise<{ newTasks: number; updatedCourses: number; removedCourses: number }>;
    clearState: () => void;
}

const SUBJECT_COLORS = ['#7C3AED', '#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#EC4899', '#06B6D4', '#8B5CF6'];

let nextTaskId = 1000;

/**
 * Auto-generate a due date exactly 7 days after the assignment date, at midnight (00:00:00).
 * Uses updateTime (when the assignment was published/shared to students) instead of
 * creationTime (when the draft was first created by faculty), because updateTime
 * represents the actual assignment date that students see in Google Classroom.
 */
function autoGenerateDueDate(assignedTime: string): string {
    const baseDate = new Date(assignedTime);
    const dueDate = new Date(baseDate);
    // Safely add 7 days using UTC time
    dueDate.setUTCDate(dueDate.getUTCDate() + 7);

    const year = dueDate.getUTCFullYear();
    const month = String(dueDate.getUTCMonth() + 1).padStart(2, '0');
    const day = String(dueDate.getUTCDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

export const useClassroomStore = create<ClassroomState>((set, get) => ({
    isConnected: false,
    isSyncing: false,
    lastSyncAt: null,
    syncError: null,
    syncedCourses: [],
    importedCourseworkIds: new Set<string>(),

    loadSyncState: async (userId: string) => {
        try {
            const syncData = await db.fetchClassroomSync(userId);
            if (syncData) {
                set({
                    syncedCourses: syncData.synced_courses as SyncedCourse[] || [],
                    importedCourseworkIds: new Set(syncData.imported_coursework_ids as string[] || []),
                    lastSyncAt: syncData.last_sync_at,
                    isConnected: true,
                });
            }
        } catch (err) {
            console.error('Failed to load classroom sync state:', err);
        }
    },

    clearState: () => {
        set({
            isConnected: false,
            isSyncing: false,
            lastSyncAt: null,
            syncError: null,
            syncedCourses: [],
            importedCourseworkIds: new Set(),
        });
    },

    syncNow: async () => {
        // Get the Google OAuth token from the Supabase session
        const { data: { session } } = await supabase.auth.getSession();
        const providerToken = session?.provider_token;

        if (!providerToken) {
            set({ syncError: 'No Google token available. Please sign out and sign in again with Google.' });
            return { newTasks: 0, updatedCourses: 0, removedCourses: 0 };
        }

        const userId = session.user.id;

        set({ isSyncing: true, syncError: null, isConnected: true });

        try {
            const classroomData = await fetchAllClassroomData(providerToken);
            const { syncedCourses, importedCourseworkIds } = get();

            let newTaskCount = 0;
            let updatedCourseCount = 0;
            let removedCourseCount = 0;
            const newSyncedCourses = [...syncedCourses];
            const newImportedIds = new Set(importedCourseworkIds);

            // ──── Reconcile: Remove courses that are no longer in Google Classroom ────
            const activeCourseIds = new Set(classroomData.map(c => c.course.id));
            const staleCourses = newSyncedCourses.filter(sc => !activeCourseIds.has(sc.id));

            // Collect all stale list IDs for batch cleanup
            const staleListIds = new Set(staleCourses.map(sc => sc.listId));
            const staleCourseIds = new Set(staleCourses.map(sc => sc.id));

            if (staleListIds.size > 0) {
                // Get fresh state and batch-remove all stale tasks
                const currentTasks = useTaskStore.getState().tasks;
                const staleTaskIds = currentTasks
                    .filter(t => staleListIds.has(t.listId))
                    .map(t => t.id);

                // Delete all stale tasks from DB
                for (const taskId of staleTaskIds) {
                    db.deleteTaskFromDB(userId, taskId).catch(err =>
                        console.error(`Failed to delete stale task ${taskId}:`, err)
                    );
                }

                // Delete all stale lists from DB
                for (const listId of staleListIds) {
                    db.deleteList(userId, listId).catch(err =>
                        console.error(`Failed to delete stale list ${listId}:`, err)
                    );
                }

                // Batch-update the store state in one go
                const freshState = useTaskStore.getState();
                useTaskStore.setState({
                    tasks: freshState.tasks.filter(t => !staleListIds.has(t.listId)),
                    lists: freshState.lists.filter(l => !staleListIds.has(l.id)),
                });

                // Clean up imported coursework IDs for removed courses
                for (const staleCourseId of staleCourseIds) {
                    const coursePrefix = `${staleCourseId}:`;
                    for (const key of newImportedIds) {
                        if (key.startsWith(coursePrefix)) {
                            newImportedIds.delete(key);
                        }
                    }
                }

                // Remove stale courses from synced courses list
                for (let i = newSyncedCourses.length - 1; i >= 0; i--) {
                    if (staleCourseIds.has(newSyncedCourses[i].id)) {
                        newSyncedCourses.splice(i, 1);
                    }
                }

                removedCourseCount = staleListIds.size;

                // Cleanup hidden list IDs
                useUIStore.getState().cleanupHiddenLists(
                    useTaskStore.getState().lists.map(l => l.id)
                );
            }

            // ──── Also check for orphaned academic lists not in syncedCourses ────
            const syncedListIds = new Set(newSyncedCourses.map(sc => sc.listId));
            const currentLists = useTaskStore.getState().lists;
            const orphanedLists = currentLists.filter(
                l => l.workspaceId === 'academic' && l.isAcademic && !syncedListIds.has(l.id)
            );

            if (orphanedLists.length > 0) {
                const orphanedListIds = new Set(orphanedLists.map(l => l.id));

                const currentTasksNow = useTaskStore.getState().tasks;
                for (const task of currentTasksNow) {
                    if (orphanedListIds.has(task.listId)) {
                        db.deleteTaskFromDB(userId, task.id).catch(err =>
                            console.error(`Failed to delete orphaned task ${task.id}:`, err)
                        );
                    }
                }
                for (const list of orphanedLists) {
                    db.deleteList(userId, list.id).catch(err =>
                        console.error(`Failed to delete orphaned list ${list.id}:`, err)
                    );
                }

                const stateNow = useTaskStore.getState();
                useTaskStore.setState({
                    tasks: stateNow.tasks.filter(t => !orphanedListIds.has(t.listId)),
                    lists: stateNow.lists.filter(l => !orphanedListIds.has(l.id)),
                });

                removedCourseCount += orphanedLists.length;

                useUIStore.getState().cleanupHiddenLists(
                    useTaskStore.getState().lists.map(l => l.id)
                );
            }

            // ──── Add/update active courses ────
            for (const { course, coursework } of classroomData) {
                let syncedCourse = newSyncedCourses.find((c) => c.id === course.id);

                if (!syncedCourse) {
                    const listId = `classroom-${course.id}`;
                    const color = SUBJECT_COLORS[newSyncedCourses.length % SUBJECT_COLORS.length];
                    const currentListCount = useTaskStore.getState().lists.filter(
                        (l) => l.workspaceId === 'academic'
                    ).length;

                    const newList: TaskList = {
                        id: listId,
                        workspaceId: 'academic',
                        name: course.name,
                        color,
                        sortOrder: currentListCount,
                        isAcademic: true,
                        courseName: course.name,
                    };

                    useTaskStore.getState().addList(newList);

                    syncedCourse = { id: course.id, name: course.name, listId };
                    newSyncedCourses.push(syncedCourse);
                    updatedCourseCount++;
                }

                // Import coursework as tasks (and fix existing tasks' due dates)
                for (const work of coursework) {
                    const courseworkKey = `${course.id}:${work.id}`;
                    const facultyDueDate = formatClassroomDueDate(work.dueDate);

                    // Use scheduledTime as the highest priority, then updateTime, then creationTime.
                    // This fixes cases where an assignment was drafted months ago but scheduled
                    // for today, keeping the due date relevant to the actual publish date.
                    const assignedTime = work.scheduledTime || work.updateTime || work.creationTime;

                    if (newImportedIds.has(courseworkKey)) {
                        // ──── Already imported — fix due date if needed ────
                        const correctDueDate = facultyDueDate || autoGenerateDueDate(assignedTime);
                        const existingTask = useTaskStore.getState().tasks.find(t =>
                            t.listId === syncedCourse!.listId &&
                            t.title === work.title &&
                            t.source === 'classroom'
                        );
                        if (existingTask && existingTask.dueDate !== correctDueDate) {
                            useTaskStore.getState().updateTask(existingTask.id, {
                                dueDate: correctDueDate,
                                createdAt: assignedTime,
                            });
                        }
                        continue;
                    }

                    // ──── New task — import it ────
                    const dueDate = facultyDueDate || autoGenerateDueDate(assignedTime);

                    const currentTaskCount = useTaskStore.getState().tasks.filter(
                        (t) => t.listId === syncedCourse!.listId
                    ).length;

                    const newTask: Task = {
                        id: `classroom-${Date.now()}-${nextTaskId++}`,
                        listId: syncedCourse.listId,
                        title: work.title,
                        description: work.description || `Assignment from ${course.name}`,
                        status: 'todo',
                        priority: facultyDueDate ? 'p2' : 'p3',
                        isUrgent: false,
                        isImportant: false,
                        dueDate,
                        isCompleted: false,
                        sortOrder: currentTaskCount + newTaskCount,
                        source: 'classroom' as const,
                        labels: [],
                        subtasks: [],
                        createdAt: assignedTime,
                    };

                    useTaskStore.getState().addClassroomTask(newTask);
                    newImportedIds.add(courseworkKey);
                    newTaskCount++;
                }
            }

            const newState = {
                isSyncing: false,
                lastSyncAt: new Date().toISOString(),
                syncedCourses: newSyncedCourses,
                importedCourseworkIds: newImportedIds,
                isConnected: true,
            };
            set(newState);

            // Persist sync state to Supabase
            await db.upsertClassroomSync(userId, {
                syncedCourses: newSyncedCourses,
                importedCourseworkIds: Array.from(newImportedIds),
                lastSyncAt: newState.lastSyncAt,
            }).catch(err => console.error('Failed to save sync state:', err));

            return { newTasks: newTaskCount, updatedCourses: updatedCourseCount, removedCourses: removedCourseCount };
        } catch (err) {
            const message = err instanceof Error ? err.message : 'Sync failed';
            set({ isSyncing: false, syncError: message });
            return { newTasks: 0, updatedCourses: 0, removedCourses: 0 };
        }
    },
}));
